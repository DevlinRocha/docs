---
title: 'Queries on unindexed columns'
metaTitle: 'Optimize Recommendations: Queries on unindexed columns'
metaDescription: "Learn about the recommendation provided by Optimize for queries on unindexed columns."
tocDepth: 3
toc: true
---

The following queries targeting the `user` model have a [`where` property](/orm/prisma-client/queries/filtering-and-sorting) for filtering on columns that do not have indexes.

```ts
await prisma.user.findFirst({
   where: {
      name: "Marc"
   }
})

await prisma.user.findFirst({
   where: {
      name: "Jon"
   }
})

await prisma.user.count({
   where: {
      name: "Nikolas"
   }
})
```

## Why is this a problem?

An index allows the database to retrieve data more quickly. An index is similar to an index in a book: it helps you quickly locate the information you're looking for without having to go through every page.

When providing Prisma with a `where` property, if there are no indexes defined for the columns provided, the database might need to look through every row in the table (a *”full table scan”*) to determine whether or not it matches the relevant conditions. This can be undesirable for several reasons:

### User experience

For large datasets, if the database needs to look through the entire table to find the matching rows, this can result in longer waiting times for users.

### Resource utilization

- **High CPU usage:** Scanning large tables can lead to increased CPU usage, affecting overall system performance.
- **Memory consumption:** More memory is used to process and hold the data during the scan.
- **Disk I/O:** Full table scans increase disk input/output operations, potentially slowing down other database activities.

:::warning

While the issues might not show up in development due to smaller datasets, they can become *significant* problems in production where datasets are typically much larger.

:::

## Recommendation

To avoid these issues, we recommend creating an index on the columns that are frequently used in filters.

Consider a `user` model with a `name` field that is frequently used in filters. You can add an index to this column as follows:

```prisma file=schema.prisma
model User {
  id       Int    @id @default(autoincrement())
  name String
  // other fields
  @@index([name])
}
```

The best way to define indexes for your schema depends factors such as the type of the column, and what database you are using. Learn more about indexes in Prisma: [Indexes Documentation](/orm/prisma-schema/data-model/indexes)

:::note

This is a general suggestion based on unindexed columns we can detect. Adding indexes can also incur storage and write performance costs.

:::

## More on database indexes

### How indexes work

Indexes work by creating a data structure that stores the indexed column's values along with pointers to the corresponding rows in the table. When you query the database using an indexed column, the database can use this index to quickly locate the relevant rows, rather than scanning the entire table.

### The trade-offs of indexing

- **Space vs. Time**: Indexing requires additional storage space to save index data, but it significantly speeds up data retrieval.
- **Update overhead**: Every time data is added to, updated in, or removed from your table, there is an overhead to keep the indexes up to date, which can slow down write operations.

### When to use indexes

- **Large datasets:** Indexes are particularly beneficial for tables with a large number of rows.
- **Frequent queries with filtering or sorting:** Use indexes on columns that are frequently when [filtering or sorting](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filtering)
- **Looking up related data:** Use indexes on foreign key columns to speed up the retrieval of related records, such as when using [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#include-a-relation)

### When not to use indexes

- **Small tables:** For tables with very few rows, the overhead of maintaining indexes might not be worth the performance gain.
- **Write-heavy tables:** Indexes can slow down write operations (`create`, `update`, `delete`) because the index needs to be updated as well. Avoid excessive indexing on models with frequent write operations.
- **Infrequently accessed tables:** If a table is not accessed often, the benefits of indexing may not justify the overhead.
- **Columns with large data:** Indexing columns that contain a huge amount of data can lead to higher storage requirements and might not provide a significant performance improvement.
- **Rarely filtered columns:** If a table is accessed often but rarely filtered by a specific column, creating an index on that column may not be beneficial.

:::warning

Even if you index a column, the database may not always use it. Many database management systems, such as PostgreSQL and MySQL, have a *query optimizer* which evaluates multiple execution plans and selects the one it estimates to be the most efficient. In some cases, this might mean ignoring an existing index in favor of another execution plan that it determines will perform better for that specific query.

:::