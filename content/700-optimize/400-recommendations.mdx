---
title: 'Recommendations'
metaTitle: 'Optimize: Recommendations'
metaDescription: "Learn about everything about the recommendations provided by Optimize."
tocDepth: 3
toc: true
---

<TopBlock>

Optimize provides recommendations focused on performance improvements such as indexing issues, excessive data retrieval, and inefficient query patterns.

</TopBlock>

## Excessive number of rows returned

The following query targeting a `User` model do not provide a [`take` option](/orm/reference/prisma-client-reference#findmany).

```ts
await user.findMany({ select: { email: "niko@prisma.io", }})
```

### Why is this a problem?

When you execute a query without specifying a limit, the query will return all relevant rows. This can be undesirable for several reasons:

#### User experience

    - **Viewing data:** Users typically need only a portion of the data at any given time, rather than all the data at once
    - **Impact on the user's device:** Displaying all the data at once can burden the user's device resources. For example, loading thousands of rows of data in a web application can cause the browser to become slow or unresponsive, consuming a significant amount of the user's device memory and CPU to display this data
    - **Waiting time:** Retrieving a large number of rows can significantly increase the time it takes get the data from the database to the user's own device.

#### Resource Utilization

    - **Unnecessary data load:** The application processes more data than required, wasting processing resources.
    - **Memory usage:** Higher memory consumption leads to inefficient memory use. In severe cases, the system can run out of memory, disrupting the service.

### Recommendation

To avoid these issues, we recommend the [`take` option](/orm/reference/prisma-client-reference#findmany) to limit the number of entries returned by your queries:

```typescript
const users = await prisma.user.findMany({
  take: 10, // Limits the number of results to 10
  // other query parameters
})
```
<br />
:::note

Before applying this recommendation, it is important to verify that your application does not depend on retrieving all results from the query. If your application requires all results, you may need to implement *pagination*. Learn more about pagination in Prisma: [Pagination Documentation](/orm/prisma-client/queries/pagination)

:::

## Queries on unindexed columns

The following queries targeting the `user` model have a [`where` property](/orm/prisma-client/queries/filtering-and-sorting) for filtering on columns that do not have indexes.

```ts
await prisma.user.findFirst({
   where: {
      name: "Marc"
   }
})

await prisma.user.findFirst({
   where: {
      name: "Jon"
   }
})

await prisma.user.count({
   where: {
      name: "Nikolas"
   }
})
```

### Why is this a problem?

An index allows the database to retrieve data more quickly. An index is similar to an index in a book: it helps you quickly locate the information you're looking for without having to go through every page.

When providing Prisma with a `where` property, if there are no indexes defined for the columns provided, the database might need to look through every row in the table (a *”full table scan”*) to determine whether or not it matches the relevant conditions. This can be undesirable for several reasons:

#### User experience

For large datasets, if the database needs to look through the entire table to find the matching rows, this can result in longer waiting times for users.

#### Resource utilization

- **High CPU usage:** Scanning large tables can lead to increased CPU usage, affecting overall system performance.
- **Memory consumption:** More memory is used to process and hold the data during the scan.
- **Disk I/O:** Full table scans increase disk input/output operations, potentially slowing down other database activities.

:::warning

While the issues might not show up in development due to smaller datasets, they can become *significant* problems in production where datasets are typically much larger.

:::

### Recommendation

To avoid these issues, we recommend creating an index on the columns that are frequently used in filters.

Consider a `user` model with a `name` field that is frequently used in filters. You can add an index to this column as follows:

```prisma file=schema.prisma
model User {
  id       Int    @id @default(autoincrement())
  name String
  // other fields
  @@index([name])
}
```

The best way to define indexes for your schema depends factors such as the type of the column, and what database you are using. Learn more about indexes in Prisma: [Indexes Documentation](/orm/prisma-schema/data-model/indexes)

:::note

This is a general suggestion based on unindexed columns we can detect. Adding indexes can also incur storage and write performance costs.

:::

### More on database indexes

##### How indexes work

Indexes work by creating a data structure that stores the indexed column's values along with pointers to the corresponding rows in the table. When you query the database using an indexed column, the database can use this index to quickly locate the relevant rows, rather than scanning the entire table.

##### The trade-offs of indexing

- **Space vs. Time**: Indexing requires additional storage space to save index data, but it significantly speeds up data retrieval.
- **Update overhead**: Every time data is added to, updated in, or removed from your table, there is an overhead to keep the indexes up to date, which can slow down write operations.

##### When to use indexes

- Large datasets: Indexes are particularly beneficial for tables with a large number of rows.
- Frequent queries with Filtering or Sorting: Use indexes on columns that are frequently when [filtering or sorting](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filtering)
- Looking Up Related Data: Use indexes on foreign key columns to speed up the retrieval of related records, such as when using [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#include-a-relation)

##### When not to use indexes

- Small tables: For tables with very few rows, the overhead of maintaining indexes might not be worth the performance gain.
- Write-heavy tables: Indexes can slow down write operations (`create`, `update`, `delete`) because the index needs to be updated as well. Avoid excessive indexing on models with frequent write operations.
- Infrequently accessed tables: If a table is not accessed often, the benefits of indexing may not justify the overhead.
- Columns with large data: Indexing columns that contain a huge amount of data can lead to higher storage requirements and might not provide a significant performance improvement.
- Rarely filtered columns: If a table is accessed often but rarely filtered by a specific column, creating an index on that column may not be beneficial.

:::warning

Even if you index a column, the database may not always use it. Many database management systems, such as PostgreSQL and MySQL, have a *query optimizer* which evaluates multiple execution plans and selects the one it estimates to be the most efficient. In some cases, this might mean ignoring an existing index in favor of another execution plan that it determines will perform better for that specific query.

:::

## Full table scans caused by LIKE operations

The following query targeting the user model provides `contains` and `endsWith` as options, which translate to `LIKE` and `ILIKE` SQL operators.

```jsx
user.findMany({ 
  where: { 
    email: { contains: "gmail.com" }, 
    name: { endsWith: "Burk" } 
  } 
})
```

### Why is this a problem?

`LIKE` and `ILIKE` operators in SQL can lead to full table scans, potentially impacting performance, especially with larger datasets:

#### UX

- **Slower load times**: Full table scans can significantly increase the time it takes to retrieve data, leading to longer wait times for users.

#### Resource utilization

- **Increased resource usage**: Full table scans increase CPU, memory usage, and disk I/O, straining system resources for your database.
- **Increased costs**: In serverless database pricing plans, more intensive resource usage can translate into higher costs.

### Recommendation

To mitigate potential performance issues, consider extracting a separate indexed String field for the substring being filtered on, or a `Boolean` field indicating the presence of a given substring. These approaches are particularly useful if you have a limited, known set of substrings.

For example, if you frequently filter on the file extension of a `filePath` field, you can create an indexed column for the file extension:

```prisma file=schema.prisma
model File {
  id            Int     @id @default(autoincrement())
  filePath      String
  fileExtension String

  @@index([fileExtension])
}
```
<br />
:::note

This solution has trade-offs, such as increased storage requirements and potential impacts on write performance due to the additional index. Consider whether this approach is beneficial for your use case.

:::